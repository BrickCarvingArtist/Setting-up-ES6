# 2. 使用ECMAScript6开发 

这一章介绍在当前的JavaScript环境下开发ECMAScript 6你需要的操作。以下涵盖的都是备选的相关工具。如果你想要一个综合的工具清单，我建议你去Addy Osmani的“[ECMAScript 6 Tools](https://github.com/addyosmani/es6-tools)”看看。 

## 2.1 现在使用ECMAScript 6 

在现在使用ECMAScript你有什么样的选择？ 

- 当前的JavaScript引擎（浏览器，Node.js，...）已经支持大部分的ES6。你可以通过以下方式来查看已支持哪些特性： 
- Kangax的“[ECMAScript 6 compatibility table](http://kangax.github.io/compat-table/es6/)”。 
- William Kapke的“[Node.js ES2015 Support](http://node.green/)”列出了在Kangax的表格中仅与Node相关的部分。 
- ES6 REPLs（交互式命令行）可以让你测试出小部分的代码。在[本章中的一个部分](https://brickcarvingartist.github.io/Setting-up-ES6/2.%E4%BD%BF%E7%94%A8ECMAScript6%E5%BC%80%E5%8F%91#2.2)列出了可用的选项。 
- 把ES6编译成ES5：特别声明，如果你需要考虑对历史遗留的引擎作支持，在相当长的一段时间里，将ES6编译成ES5是唯一可选操作。将源码编译成源码也可以称之为源码翻译。你可以在部署环境（静态地）和运行时（动态地）用源码翻译的方式来使用ES6。这一章会阐述如何让它运转，以及其他的既有ES6工具和库。 

ES6是ES5的超集是一个可喜点，这意味着你所有的基于ES5的代码都是在ES6中生效的。因为你可以逐渐的去使用它，这也帮助你更快接受专属ES6的特性。 

## <span id="2.2">2.2 ES6 REPLs</span> 

市面上有很多REPLs（命令行）用来交互地与ES6互动。以下项目提供丰富的选择为在线编码提供互动的玩乐场所： 

- [TypeScript Playground](http://www.typescriptlang.org/Playground) 
- [Babel REPL](https://babeljs.io/repl/) 
- [Traceur Transcoding Demo](http://google.github.io/traceur-compiler/demo/repl.html) 
- [Closure Compiler Service](https://closure-compiler.appspot.com/) 

另外，Babel通过它的[babel-node工具](https://leanpub.com/setting-up-es6/read#sec_babel-node)将对ES6特性的支持带到Node.js。 

## 2.3 源码翻译工具 

有三个必要的选择你需要为代码翻译工具准备： 

- 一个代码翻译器（为你的代码服务） 
- 一个包管理工具（用来安装已有的库） 
- 一个模块系统 （为了完整的应用） 

需要注意的是这些选择都不全是独立存在的；不是每一个模块系统都可以和每一个其它包管理工具一起运作。下一章详细介绍这些选择中的每一项。 

### 2.3.1 选择一个翻译器 

一个翻译器能将ES6的代码翻译成ES5。有名的选择有： 

- [Microsoft TypeScript](http://www.typescriptlang.org/)：是一个基础的ECMAScript6+可配置的类型注解。 
- [Google Traceur](https://github.com/google/traceur-compiler)：是最具人气的ES6翻译器。是法语发音，/tʁa.sœʁ/；用英语的话接近地发音成“truh-SIR” （[来源](https://github.com/google/traceur-compiler/issues/1875), [听法语母语的人对这个单词的发音](http://www.forvo.com/word/traceur/)）。
- [Babel](https://babeljs.io/)：是一个更新的，事实上即将成为标准的ES6翻译器。Babel除了支持ES6以外，还支持React的JSX语法。发音为“babble”（想象一下澳大利亚的重音 - Babel的创造者，澳大利亚的Sebastian McKenzie）。 
- [Closure Compiler](https://developers.google.com/closure/compiler/)：如果你用接下来的两个命令行选项，就能够当作例如ECMAScript6至ECMAScript5的静态翻译： 
 - 指定输入语言：`--language ECMASCRIPT6_STRICT` 
 - 指定输出语言：`--language_out ECMASCRIPT5` 

原则上，翻译器以下面任意一种方式完成翻译： 

- 静态地（部署环境之前）或者 
- 动态地（在运行时）

### 2.3.3.1 静态翻译 

作为一个构建步骤，TypeScript，Traceur，Babel和Closure Compiler让你在以下格式化模块中提供ES5代码。你可以任意直接得调用他们或者用一个构建工具（grunt，gulp，broccoli，或其它）。 

- AMD 
- CommonJS 
- ES6 module loader API：使用这个API会通过polyfill把ES6代码翻译成ES5。 

在浏览器上，很多ES5模块都是通过等会儿介绍的模块系统之一来加载。在Node.js上，你可以用内置的模块系统（也存在其他的选择，比如webpack和ES6模块加载器polyfill）。 

### 2.3.1.2 动态代码翻译

在浏览器上，你通过一个库加上一个定制的`<script type="...">`动态编译。这个操作在[Traceur](https://github.com/google/traceur-compiler/wiki/Getting-Started)和[Babel](https://babeljs.io/docs/usage/browser/)上存在。 

在Node.js上，Babel有工具可以进行在空编译。这些会在[另一个章节](https://brickcarvingartist.github.io/Setting-up-ES6/2.%E4%BD%BF%E7%94%A8ECMAScript6%E5%BC%80%E5%8F%91#3.4)描述。

## 2.3.2 选择一个包管理工具 

你需要一个包管理工具来安装第三方库。这是三个有名的：

- [npm](https://www.npmjs.com/)：Node.js的与生俱来创建的包管理工具，在客户端开发中的受欢迎程度多亏像browserify和webpack这样的模块打包和加载工具得以持续增长。包含CommonJS模块的包和／或比如命令行工具的其它内容。 
- [Bower](http://bower.io/)：客户端代码的包管理工具。最知名的包是AMD模块，但是CommonJS模块，CSS，HTML和其它物件也能通过它管理。 
- [jspm](http://jspm.io/)：SystemJS的包管理工具（看下一个bullet list）。它能通过多样的来源安装模块，包括Github和npm。jspm的一个关键特性是外部模块能用ES6书写（会被代码翻译）。不仅是你自己的模块。 

## 2.3.3 选择一个模块系统 

模块系统让浏览器支持模块化（Node.js有一个内置模块系统）。那样，你可以通过模块系统构建出你自己的应用和库模块。有名的模块系统有： 

- [RequireJS](http://requirejs.org/)：是一个AMD模块的加载器，它可以静态地通过TypeScript，Traceur，Babel和Closure Compiler创建。模块插件（基于Traceur和Babel）让它可以加载ES6模块。 
- [Browserify](http://browserify.org/)：打包CommonJS模块（包括通过npm安装的那些模块）用以让它们通过浏览器加载。通过基于Traceur和Babel的转换器（插件）支持ES6模块。 
- [webpack](http://webpack.github.io/)：一个CommonJS模块（包括通过npm安装的那些模块）或AMD模块（包括通过Bower安装的那些模块）都可以用的打包和加载工具。通过定制基于Traceur和Babel的加载器（插件）以支持ES6模块。 
- [SystemJS](https://github.com/systemjs/systemjs)：一个支持ES6模块及用CommonJS，AMD和“ES6 module loader API”格式书写的ES5模块，基于ES6模块加载器Polyfill的模块系统。 

# 2.4 其它有用的ES6工具和库 

## 2.4.1 Linters和检查器

Linters和检查器静态地分析源码并反馈与风格，方式等相关的问题。 

下面的Linters都支持ES6，但是取自不同的角度： 

- [JSLint](http://www.jslint.com/)（关注：强制代码规范书写） 
- [JSLint](http://jshint.com/)（关注：强制代码规范书写） 
- [ESLint](http://eslint.org/)（关注：允许人们用他们自己的风格实现规范） 
- [JSCS](http://jscs.info/)（关注：强制代码风格) 

下面的检查器都支持ES6： 

- [Flow](http://flowtype.org/)：会被类型检查的代码。它以以下三个来源获得类型信息： 
 - 类型注解语法（非规范的） 
 - [在注释中做类型注解](http://flowtype.org/blog/2015/02/20/Flow-Comments.html) 
 - 类型接口（通过静态地统计源码进行类型推断，甚至完全没有注解的代码Flow都是有效的） 
- [TypeScript](http://www.typescriptlang.org/)：除了可以作为一个代码翻译器，TypeScript的编译器和也与Flow的运作方式类似并且对类型问题作警告。 
- [Closure Compiler](https://developers.google.com/closure/compiler/docs/js-for-compiler)：会被类型检查的代码并且能理解存在JSDoc标记中的类型信息。 

## 2.4.2 测试工具 

很多测试工具（比如Jasmine和mocha）能被以最多得使用因为他们能与被代码翻译后的代码一起运作，所以他们没有必要去理解ES6的原始代码。[Babel的文档](http://babeljs.io/docs/setup/)中有关于如何去与非常多测试工具一起使用的信息。 

## 2.4.3 Shims／polyfills 

Shims／polyfills用ES5代码让你可以使用满足ECMAScript6规范的库： 

- [es6-shim](https://github.com/paulmillr/es6-shim/) 
- [Core.js](https://github.com/zloirock/core-js)（Babel在用它） 

## 2.4.4 ES6句法分析器 

这里有一些可以处理ES6的句法分析器： 

- [Esprima](http://esprima.org/) 
- [Acorn](https://github.com/marijnh/acorn) 
- Babel最近已经成为不只是一个能静态分析和转换JavaScript源码的框架了。“[Babel Plugin Handbook](https://github.com/thejameskyle/babel-plugin-handbook)”（来自James Kyle）提供了部分关于Babel为什么能够运行的信息。 