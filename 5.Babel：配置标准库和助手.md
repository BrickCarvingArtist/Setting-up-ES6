## 5.Babel：配置标准库和助手 

> 转载请注明出处 https://brickcarvingartist.github.io/Setting-up-ES6/5.Babel%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E5%8A%A9%E6%89%8B 

这一章阐述如何配置及Babel6如何接入它自身的帮手方法和ES6标准库。 

下面的Github仓库让你与我们在这里阐述的东西玩耍：[babel-config-demo](https://github.com/rauschma/babel-config-demo) 

### 5.1 概览 

通过Babel提供的代码通常有两种外部依赖： 

- 助手方法（比如给子类用的） 
- 标准库功能（比如Map或者ES6字符串方法） 

实现这些依赖有两种方式：通过全局安装功能或通过模块。两种情况下的功能都有npm包交付。 

#### 5.1.1 来自全局变量的额外依赖 

下面的npm包全局安装它们变量并让你通过全局变量接入它： 

- （P）`babel-plugin-external-helpers`和（I）生成的文件：全局帮手 
- （I）`babel-polyfill`：全局标准库 
 - ES5，ES6+，运行时再生器 
- （I）`core-js`：全局标准库 
 - `core-js/shim`：ES5，ES6+ 
 - `core-js/es6`：ES6 

装配： 

- （P）插件：以一个开发依赖安装的npm包并在Babel配置信息（参见“[配置Babel6](https://brickcarvingartist.github.io/Setting-up-ES6/4.%E9%85%8D%E7%BD%AEBabel6)”章节）。 
- （I）导入：以一个运行时依赖安装npm包并在开始编码时导入。 

#### 5.1.2 通过模块引入外部依赖 

下面的npm包可通过模块用依赖： 

- （P）`babel-plugin-transform-runtime`，（M）`babel-runtime`：通过引入的帮手和标准库（插件生成各引入）。 
 - Babel帮手（委托者） 
 - 标准库（可被关闭） 
 - 重生器API（可被关闭） 
- （M）`core-js`：来自模块的标准库。 
 - 单体： 

```js
import _repeat from 'core-js/library/fn/string/repeat';
``` 

 - 命名空间对象（ES5，ES6+）： 

```js
import * as core from 'core-js/library';
const myStr = core.String.repeat('*', 10);
``` 

 - 命名空间对象（ES6）： 

```js
import * as core from 'core-js/library/es6';
const myStr = core.String.repeat('*', 10);
``` 

装配： 

（P）插件：以一个开发依赖安装的npm包并在Babel配置信息（参见“[配置Babel6](https://brickcarvingartist.github.io/Setting-up-ES6/4.%E9%85%8D%E7%BD%AEBabel6)”章节）。 

（M）模块：以运行时依赖安装npm包并在运行时引入单体（当需要时）。 

### 5.2 来自代码编译过的代码的外部依赖 

通过Babel生成的代码在两种额外的依赖中需要被实现。 

第一种，大多数代码调用ES6标准库中功能。默认的，你通过全局变量接入这些功能： 

```js
let m = new Map();
if (str.startsWith('/')) ···
``` 

第二种，Babel的被代码翻译过的代码调用帮手方法（比如给子类用的）。默认的，帮手方法是行内的，插入每个文件。比如（`_classCallCheck`是一个帮手方法）： 

```
//---------- 输入：ES6代码
class Person {}

//---------- 输出：用了帮手方法的ES5代码
"use strict";

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var Person = function Person() {
    _classCallCheck(this, Person);
};
``` 

一旦同样的帮手在多个文件中被使用各行内帮手会带到代码复制集中。 

你能得到标准库和非行内帮手有其中的两种选择：通过全局变量和通过模块导入。如何去做会被下节中介绍。 

### 5.3 来自全局变量的外部依赖 

#### 5.3.1 来自全局变量的帮手：babel-plugin-external-helpers 

有两个东西你需要下载： 

- 插件`babel-plugin-external-helpers`： 
 - 以开发环境依赖安装： 

```bash
npm install --save-dev babel-plugin-external-helpers
``` 

 - 在Babel配置信息中激活： 

```json
"plugins": ["external-helpers"]
``` 

- 设置上全局变量的`babelHelpers`文件： 
 - 需要在运行时加载或引入，越早越好。举个例子： 

```js
import 'babelHelpers';
``` 

 - 来自命令行工具`babel-external-helpers`（如何去做会被下节中介绍）生成的。 
 - 以一个开发依赖安装`babel-external-helpers`： 
```bash
npm install --save-dev babel-cli
``` 

这插件确保所有帮手通过全局对象`babelHelpers`的各方法调用。在这节，我将阐述它如何运作。在下一节，我会介绍如何假设`babelHelpers`。 

作为一个例子，考虑下面的ES6代码，在代码编译前： 

```js
class Point {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
	toString() {
		return `(${this.x}, ${this.y})`;
	}
}
``` 

如果你不与`external-helpers`而单用`ES2016`前置项代码翻译它，你会得到： 

```js
"use strict";

var _createClass = (function () {
	···
})();

function _classCallCheck(instance, Constructor) {
	···
}

var Point = (function () {
	function Point(x, y) {
		_classCallCheck(this, Point);

		this.x = x;
		this.y = y;
	}

	_createClass(Point, [{
		key: "toString",
		value: function toString() {
			return "(" + this.x + ", " + this.y + ")";
		}
	}]);

	return Point;
})();
``` 

注意两个帮手函数`_createClass`和`_classCallCheck`。 

如果你激活了`external-helpers`插件，你会得到这个输出： 

```js
"use strict";

var Point = (function () {
	function Point(x, y) {
		babelHelpers.classCallCheck(this, Point);

		this.x = x;
		this.y = y;
	}

	babelHelpers.createClass(Point, [{
		key: "toString",
		value: function toString() {
			return "(" + this.x + ", " + this.y + ")";
		}
	}]);
	return Point;
})();
``` 

##### 5.3.1.1 安装全局的Babel帮手 

你如何有各帮手的对象到全局变量`babelHelpers`中？通过一个有命令行工具`babel-external-helpers`生成的文件。这个工具是npm包`babel-cli`的一部分。这个文件适用三种格式： 

- `babel-external-helpers -t global`

显印一个置入各帮手至`global.babelHelpers`的Node.js模块。 

- `babel-external-helpers -t var` 

显印一个以`var`声明至全局作用域并将一个有各帮手的对象转赋至它的`babelHelpers`的脚本文件（浏览器代码）。 

- `babel-external-helpers -t umd` 

显印一个以CommonJS模块，AMD模块及以一个脚本（通过全局变量）运作的普适模块定义（UMD）。 

这个调用会显印有用的信息： 

```bash
babel-external-helpers --help
``` 

#### 5.3.2 标准库以及更多来自各全局变量的：babel-polyfill 

[babel-polyfill](https://babeljs.io/docs/usage/polyfill/)包含了一个会安装一些东西到全局变量里去的模块： 

- [ES5 polyfills](https://github.com/zloirock/core-js#ecmascript-5)（无论是否在ES5标准库里缺失）：`Object.create()`，`Array.prototype.forEach()`等等。 
- [ES6 polyfills](https://github.com/zloirock/core-js#ecmascript-6)：`Map`，`String.prototype.repeat()`等等。 
- [一些ECMAScript未来提案的polyfills](https://github.com/zloirock/core-js#ecmascript-7-proposals)：`Object.entries()`，`Array.prototype.includes()`等。 
- 在运行时用的[重生器](http://facebook.github.io/regenerator/)（那些由Babel去用来代码翻译ES6生成ES5的）。 
- polyfills由`[core-js](https://github.com/zloirock/core-js)`提供，正如你所见当你看到两个导入表达式构成[这个模块](https://github.com/babel/babel/blob/master/packages/babel-polyfill/src/index.js)： 

```js
import "core-js/shim";
import "babel-regenerator-runtime";
``` 

##### 5.3.2.1 安装 

当你发现任意以上功能在你的代码翻译的代码中缺失时通过npm以一个运行时的依赖安装`babel-polyfill`。在当前的各Node.js版本（译者注：指7.0+版本），你大概不需要用到它，因为这些版本携带着大多数ES6标准库和本地化的生成器。 

这个模块被通过这样安装： 

```bash
npm install --save babel-polyfill
``` 

你必须在使用标准库之前引入它： 

```js
import 'babel-polyfill';
``` 

这个模块将检查全局变量并只会安装缺失的功能。这个polyfill的负面是你总是交付并加载全部的功能，无关你要用多少。 

---

## 感谢支持译者翻译 

![支持译者继续翻译](http://static.ikindness.cn/donate.png)

---

首页：[架设ES6](https://brickcarvingartist.github.io/Setting-up-ES6) 

上一章：[配置Babel6](https://brickcarvingartist.github.io/Setting-up-ES6/4.%E9%85%8D%E7%BD%AEBabel6)